<html>
<head>
    <title>Our 3D creation</title>

    <!-- This is the CSS style of this page. -->
    <link rel="stylesheet" href="stylesheet.css" type="text/css">

</head>


<body>
    <!--include the three.js library-->
    <script src="js/three.js"></script>
    <!--and the trackball code-->
    <script src="js/OrbitControls.js"></script>
    <!--include the dat.gui.min.js library to edit the scene in real time-->
    <script src="js/dat.gui.min.js"></script>
    <!--include the stats.js library-->
    <script src="js/stats.js"></script>


    <!-- This div element is the top text space on the page. -->
    <div id="info">
        <p>This is a threeJS Test <br> Tried by Amy </p>
    </div>

    <!-- This script section is where we add THREE.JS code. -->
    <script>
        //create the scene and camera
        var scene = new THREE.Scene();

        // Monitor the performance.
        var stats = new Stats();
        document.body.appendChild(stats.dom);

        // Create interaction control panel.
        var gui = new dat.GUI();

        // Add fog effect to the scene. This is white right now.
        //scene.fog = new THREE.FogExp2(0xffffff, 0.04);

        var ratio = window.innerWidth / window.innerHeight;
        var camera = new THREE.PerspectiveCamera(45, ratio, 1, 1000);
        // Place the camera (at the coordinate of its neareast parent.)
        camera.position.set(1, 5, 8);
        // Determine which point the camera is looking at.
        camera.lookAt(0, 0, 0);

        // Controller to control the position of the camera.
        var cameraZRotation = new THREE.Group();
        var cameraZPosition = new THREE.Group();
        var cameraXRotation = new THREE.Group();
        var cameraYRotation = new THREE.Group();

        cameraZRotation.add(camera);
        cameraZPosition.add(cameraZRotation);
        cameraXRotation.add(cameraZPosition);
        cameraYRotation.add(cameraXRotation);

        cameraZPosition.position.z = 25;

        scene.add(cameraYRotation);

    </script>

    <!-- This script section is the function to create and to update the renderer. -->
    <script src="scripts/UpdateRenderer.js"></script>

    <!-- This script section stores the functions about creating objects. -->
    <script src="scripts/CreateObjects.js"></script>


    <!-- This script section is where we add THREE.JS code. -->
    <script>
        // Use the clock to calculate time elapse.
        var clock = new THREE.Clock();

        // Make texture for objects.
        var loader = new THREE.TextureLoader();

        scene.background = CubeMap();

        // Change the color of the background to grey.
        renderer.setClearColor(0x555555);

        var box = getBoxGrid(5, 0.8);
        var plane = getPlane(6);

        // Name property can allow this object to be gotten later with it.
        plane.name = 'plane-to-get-by-name';
        box.name = 'box-to-get-by-name';

        // Rotate the plane 90 degree.
        plane.rotation.x = Math.PI / 2;


        scene.add(box);
        scene.add(plane);



        // After creating a point light, you must place it at a right coordinate.
        var pointLight = getPointLight(1);
        pointLight.position.y = 1.5;
        pointLight.position.x = -1;
        pointLight.position.z = 2;
        scene.add(pointLight);

        // Use gui to control the light. Param => (object, propertyName, min, max)
        gui.add(pointLight, 'intensity', 0.5, 5);
        gui.add(pointLight.position, 'y', 1, 2);
        gui.add(pointLight.position, 'x', -3, 3);
        gui.add(pointLight.position, 'z', -3, 3);
        // gui.add(spotLight, 'penumbra', 0, 1);

        // Make a sphere to represent the point light.
        var sphere = getSphere(0.05);
        pointLight.add(sphere);

        // Help the shadow casting of the light.
        var helper = new THREE.CameraHelper(pointLight.shadow.camera);
        scene.add(helper);

        var ambientLight = getAmbientLight(2);
        scene.add(ambientLight);

        // Control camera position.
        gui.add(cameraZPosition.position, 'z', 0, 100);
        gui.add(cameraXRotation.rotation, 'x', -Math.PI, Math.PI);
        gui.add(cameraYRotation.rotation, 'y', -Math.PI, Math.PI);

        // Particle system.
        var particleGeo = new THREE.Geometry();

        var particleMat = new THREE.PointsMaterial({
            color: 'rgb(255, 255, 255)',
            size: 1,
            map: new THREE.TextureLoader().load('img/textures/particle.jpg'),
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        var particleCount = 20000;
        var particleDistance = 100;

        // Push random points to the geometry.
        for (var i = 0; i < particleCount; i++) {
            var posX = (Math.random() - 0.5) * particleDistance;
            var posY = (Math.random() - 0.5) * particleDistance;
            var posZ = (Math.random() - 0.5) * particleDistance;
            // Make a point with the Vector3 object.
            var particle = new THREE.Vector3(posX, posY, posZ);

            particleGeo.vertices.push(particle);
        }

        // Create the system.
        var particleSystem = new THREE.Points(
            particleGeo,
            particleMat
        );
        scene.add(particleSystem);


        //////////////
        // CONTROLS //
        //////////////

        // move mouse and: left   click to rotate,
        //                 middle click to zoom,
        //                 right  click to pan
        // add the new control and link to the current camera to transform its position
        controls = new THREE.OrbitControls(camera, renderer.domElement);


        // Constantly update the renderer/scene.
        var MyUpdateLoop = function () {
            //call the render with the scene and the camera
            renderer.render(scene, camera);
            // Update the stats to monitor.
            stats.update();

            // Get the plane when you can't use the var reference outside the fuction.
            var planeRef = scene.getObjectByName('plane-to-get-by-name');
            planeRef.rotation.z += 0.001;

            if (cameraZPosition.position.z > 0)
                cameraZPosition.position.z -= 0.05;

            // Get the box without a new var. The outside var box is accesible here.
            // Change the scale of every child of this scene with traverse method.
            box.traverse(function (child) {
                if (child.name != 'box-to-get-by-name')
                    child.rotation.y += 0.001;
            });

            // Calculate time elapsed with the clock.
            var timeElapsed = clock.getElapsedTime();

            // Rotate camera left and right.
            //cameraZRotation.rotation.z += Math.sin(timeElapsed) * 0.001 * Math.PI;
            cameraZRotation.position.y += Math.sin(timeElapsed * 5) * 0.01 * Math.PI;

            // Changing shape of the boxes.
            box.children.forEach(function (child, index) {
                child.scale.y = (Math.sin(timeElapsed * 5 + index) + 1) / 2 + 0.001;
                child.position.y = child.scale.y / 4;
            });

            // Torture the shape.
            plane.geometry.vertices.forEach(function (vertex, index) {
                vertex.z += Math.sin(timeElapsed + index * 0.1) * 0.005;
            });
            // Make the shape changeable in updating
            plane.geometry.verticesNeedUpdate = true;

            //finally perform a recoursive call to update again
            //this must be called because the mouse change the camera position
            requestAnimationFrame(MyUpdateLoop);
        };

        requestAnimationFrame(MyUpdateLoop);

    </script>


</body>
</html>








