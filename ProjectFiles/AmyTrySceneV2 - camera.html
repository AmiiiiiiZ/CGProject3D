<html>
<head>
    <title>Our 3D creation</title>

    <!-- This is the CSS style of this page. -->
    <link rel="stylesheet" href="stylesheet.css" type="text/css">
    <meta http-equiv="Content-type" content="text/html; charset=UTF-8" />

</head>

<body>

    <!-- This div element is the top text space on the page. -->

</body>

    <!--include the sql.js library-->
    <script type="text/javascript" src="js/sql.js"></script>
    <!--include the three.js library-->
    <script src="js/three.js"></script>
    <!--and the trackball code-->
    <script src="js/OrbitControls.js"></script>
    <!--include the dat.gui.min.js library to edit the scene in real time-->
    <script src="js/dat.gui.min.js"></script>
    <!--include the stats.js library-->
    <script src="js/stats.js"></script>
        <!-- This script section is the function to create and to update the renderer. -->
    <script src="scripts/UpdateRenderer.js"></script>

    <!-- This script section stores the functions about creating objects. -->
    <script src="scripts/CreateObjectsNew.js"></script>

    <!-- This script section stores the functions about controlling the box with your keyboard. -->
    <script src="scripts/KeyboardOperation.js"></script>
    <!-- This script section is where we add THREE.JS code. -->
    <script>
        //create the scene and camera
        var scene = new THREE.Scene();

        // Monitor the performance.
        var stats = new Stats();
        document.body.appendChild(stats.dom);

        // Create interaction control panel.
        var gui = new dat.GUI();

        var ratio = window.innerWidth / window.innerHeight;
        var camera = new THREE.PerspectiveCamera(45, ratio, 1, 1000);
        // Place the camera (at the coordinate of its neareast parent.)
        camera.position.set(12, 18, 28);
        
        // Determine which point the camera is looking at.
        camera.lookAt(0, 0, 0);
        
        
			var cameralight = new THREE.PointLight( new THREE.Color(1,1,1), 0.8 );
  			camera.add( cameralight );
 			scene.add(camera);
 			scene.add(cameralight);

    		
    		var camera2 = new THREE.PerspectiveCamera(45,ratio,1,1000);
			camera2.position.set(0,2,5);
			camera2.lookAt(scene.position);	
				  
			var cameralight2 = new THREE.PointLight( new THREE.Color(1,1,1), 0.8 );
  			camera2.add( cameralight2 )
			
		var strDownloadMime = "image/octet-stream";
		var saveLink = document.createElement('div');
        saveLink.style.position = 'absolute';
        saveLink.style.bottom = '10px';
        saveLink.style.width = '100px';
        saveLink.style.background = '#FFFFFF';
        saveLink.style.textAlign = 'center';
        saveLink.innerHTML =
            '<a href="#" id="saveLink">Save Frame</a>';
        document.body.appendChild(saveLink);
        document.getElementById("saveLink").addEventListener('click', saveAsImage);
        
        //Add camera move
		var cameraMove = document.createElement('div');
        cameraMove.style.position = 'absolute';
        cameraMove.style.bottom = '100px';
        cameraMove.style.width = '100px';
        cameraMove.style.background = '#FFFFFF';
        cameraMove.style.textAlign = 'center';
        cameraMove.innerHTML =
            '<a href="#" id="cameraMove">Camera Move</a>';
        document.body.appendChild(cameraMove);
        document.getElementById("cameraMove").addEventListener('click', changeCamera);
				
				
		var showVariable = document.createElement('div');
		showVariable.style.position = 'absolute';
        showVariable.style.bottom = '300px';
        showVariable.style.width = '100px';
        //showVariable.style.background = '#FFFFFF';
        showVariable.style.textAlign = 'center';
		showVariable.style.color = 'black';
		showVariable.innerHTML = "Hi";
		document.body.appendChild(showVariable);
				
				
        // Change the color of the background to grey.
        renderer.setClearColor(0x555555);

        var box = getBox(1, 1, 1, 0xffffff);
        box.position.set(0, 0, 0);

        // Create a plane to see the grid. Always use odd number, ohterwise the position is not accurate.

        var ground = getPlane(101);
        ground.position.y = -0.50;
        ground.material.color.setHex(0x88aa88);
        ground.material.wireframe = false;
        scene.add(ground);

        scene.add(box);

		
		var group = new THREE.Group();
		group.add(getCar());
		
		var wheel1 = getWheel(-1.2,-0.2,-1.2);
		var wheel2 = getWheel(1.2,-0.2,-1.2);
		var wheel3 = getWheel(-1.2,-0.2,1.2);
		var wheel4 = getWheel(1.2,-0.2,1.2);
		var backlight1 = getBackLight(-1,0.8,2.5);
		var backlight2 = getBackLight(1,0.8,2.5);
		//back1
		var material_back = new THREE.MeshPhongMaterial();
		material_back.color=  new THREE.Color(1,0,0);
		var geometry_back = new THREE.BoxGeometry(0.6,0.3,0.6);
		var back1 = new THREE.Mesh(geometry_back,material_back);
		var back2 = new THREE.Mesh(geometry_back,material_back);
		back1.position.set(-1,0.55,1.75);
		back2.position.set(1,0.55,1.75);
		
		group.add(wheel1);
		group.add(wheel2);
		group.add(wheel3);
		group.add(wheel4);
		group.add(backlight1);
		group.add(backlight2);
		group.add(back1);
		group.add(back2);

		var camera_flag = 1;
		var moveForward=false;
		var moveLeft=false;
		var moveBackward=false;
		var moveRight=false;

		//final update loop

		function changeCamera() {
					
			camera_flag *= -1;
					
				if (camera_flag < 0){
					scene.add(group);
					scene.add(camera2);
					scene.remove(cameralight);
					scene.remove(camera);
				} 
				if (camera_flag > 0) {
				//scene.remove(group);
					scene.remove(camera2);
					scene.remove(cameralight2);
					scene.add(camera);
					scene.add(cameralight);
				}
					
		}
    const clock = new THREE.Clock();

    //var speed=2;
    //var angle=0;
    var MyUpdateLoop = function ( )
    {
    	stats.update();
    	
		var delta = clock.getDelta(); // seconds.
		var moveDistance = 5 * delta; // 200 pixels per second
		var rotateAngle = Math.PI / 2 * delta;   // pi/2 radians (90 degrees) per second
		var rotation_matrix = new THREE.Matrix4().identity();
    
		if (moveLeft==true)
		{
        //angle+=speed*delta;
        //Dir.x=Math.sin(rotateAngle);
        //Dir.z=Math.cos(rotateAngle);
        //Dir.normalize();
        group.rotateOnAxis( new THREE.Vector3(0,1,0), rotateAngle);
		}
		  if (moveRight==true)
		  {
			//angle-=speed*delta;
			//Dir.x=Math.sin(rotateAngle);
			//Dir.z=Math.cos(rotateAngle);
			//Dir.normalize();
			group.rotateOnAxis( new THREE.Vector3(0,1,0), -rotateAngle);
		  }
		  if (moveForward==true)
		  {
			//Pos.x+=Dir.x*speed*delta;
			//Pos.z+=Dir.z*speed*delta;
			group.translateZ( -moveDistance );
			wheel1.rotateOnAxis( new THREE.Vector3(0,1,0), 0.3);
			wheel2.rotateOnAxis( new THREE.Vector3(0,1,0), 0.3);
			wheel3.rotateOnAxis( new THREE.Vector3(0,1,0), 0.3);
			wheel4.rotateOnAxis( new THREE.Vector3(0,1,0), 0.3);
			 
		  }
		  if (moveBackward==true)
		  {
			//Pos.x-=Dir.x*speed*delta;
			//Pos.z-=Dir.z*speed*delta;
			group.translateZ(  moveDistance );
			wheel1.rotateOnAxis( new THREE.Vector3(0,1,0), -0.3);
			wheel2.rotateOnAxis( new THREE.Vector3(0,1,0), -0.3);
			wheel3.rotateOnAxis( new THREE.Vector3(0,1,0), -0.3);
			wheel4.rotateOnAxis( new THREE.Vector3(0,1,0), -0.3);
		  }
      //recompute direction
      var relativeCameraOffset = new THREE.Vector3(0,2,10);

		var cameraOffset = relativeCameraOffset.applyMatrix4( group.matrixWorld );

			camera2.position.x = relativeCameraOffset.x;
			camera2.position.y = relativeCameraOffset.y;
			camera2.position.z = relativeCameraOffset.z;
			camera2.lookAt( group.position );
			
      //call the render with the scene and the camera
      
      if( camera_flag<0) {
      	renderer.render(scene,camera2);
      	showVariable.innerHTML = "flag at 2 : " + camera_flag + ", " + moveForward;
      	
    } else {
    	renderer.render(scene,camera);
   		showVariable.innerHTML = "flag at 1 : " + camera_flag + ", " + moveForward;
    		
    }

      camera.updateProjectionMatrix();
      camera2.updateProjectionMatrix();
      
      colorChanger.SetColor();
      requestAnimationFrame(MyUpdateLoop);

    };

        // Update box color
        var Color = function () {
            this.color = 0xee6666; // RGB with alpha

            // Define render logic ...
            box.material.color.setHex(this.color);

            this.SetColor = function(){
                box.material.color.setHex(this.color);
            }
        };

    function saveAsImage() {
        var imgData, imgNode;

        try {
            var strMime = "image/jpeg";
            imgData = renderer.domElement.toDataURL(strMime);
						saveFile(imgData.replace(strMime, strDownloadMime), "test.jpg");
						
						       
        } catch (e) {
            console.log(e);
            return;
        }

    };

    var saveFile = function (strData, filename) {
    		
        var link = document.createElement('a');
        if (typeof link.download === 'string') {
        		
        		
        		if (typeof window.navigator.msSaveBlob !== 'undefined') { // IE
                //var blob = new Blob([blob], { type: 'application/pdf' });
                //window.navigator.msSaveBlob(blob, filename);
                //var html="<img src='"+strData+"' alt='canvas image'/>";
		        		//var newTab=window.open();
		        		//newTab.document.write(html);
		        		
		        		// convert base64 to raw binary data held in a string
						    var byteString = atob(strData.split(',')[1]);

						    // separate out the mime component
						    var mimeString = strData.split(',')[0].split(':')[1].split(';')[0];

						    // write the bytes of the string to an ArrayBuffer
						    var arrayBuffer = new ArrayBuffer(byteString.length);
						    var _ia = new Uint8Array(arrayBuffer);
						    for (var i = 0; i < byteString.length; i++) {
						        _ia[i] = byteString.charCodeAt(i);
						    }

						    var dataView = new DataView(arrayBuffer);
						    var blob = new Blob([dataView], { type: mimeString });
						    
						    window.navigator.msSaveBlob(blob, filename);
						    
            } else {//if (typeof window.chrome !== 'undefined') { // Chrome
		            document.body.appendChild(link); //Firefox requires the link to be in the body
		            link.download = filename;
		            link.href = strData;
		            link.click();
		            document.body.removeChild(link); //remove the link when done
            
		      }
        } else {
            location.replace(uri);
        }

    };
		



        var colorChanger = new Color();

        gui.addColor(colorChanger, 'color');


        // Environment light
        var ambientLight = getAmbientLight(1);
        scene.add(ambientLight);

       
        var saveLink = document.createElement('div');
				/* var pointLight = getPointLight(1);
        scene.add(pointLight);
        */
        //gui.add(pointLight, 'intensity', 0.5, 5);
        //gui.add(pointLight.position, 'y', 10, 30);
        //gui.add(pointLight.position, 'x', -30, 30);
        //gui.add(pointLight.position, 'z', -30, 30);




        //////////////
        // CONTROLS //
        //////////////

        // move mouse and: left   click to rotate,
        //                 middle click to zoom,
        //                 right  click to pan
        // add the new control and link to the current camera to transform its position
        controls = new THREE.OrbitControls(camera, renderer.domElement);


        requestAnimationFrame(MyUpdateLoop);
        
				 //this fucntion is called when the window is resized
    var MyResize = function ( )
    {
      var width = window.innerWidth;
      var height = window.innerHeight;
      renderer.setSize(width,height);
      camera.aspect = width/height;
      camera.updateProjectionMatrix();
      camera2.aspect = width/height;
      camera2.updateProjectionMatrix();
      renderer.render(scene,camera);
    };

    //link the resize of the window to the update of the camera
    window.addEventListener( 'resize', MyResize);
    </script>


</html>








